### Get 和Post 的区别

* 1 传输方式上，get通过url，post通过request body  

* 2 http协议并未规定get和post的长度限制 post数据量无限制，get 有限制，跟url 长度限制一样，不同浏览器和服务端对url 的限  制不一样，支持Chrome，则最大长度8182byte  

* 3 数据类型，get 只能发送字符串，post能更多的类型，json,form-data  

* 4 意义，get 是用来获取信息的，post是用来写入或者修改数据的  

* 5 post比get慢，一个原因post在真正接收数据之前会先将请求头发送给服务器进行确认，post 包含更多的请求头，get会将数据缓存起来 ，而post不会

### HTTP与HTTPS区别

https 实在http 的基础上，在传输层和应用层中间加了一层TLS, 用来加密。TLS由SSL握手协议，SSL修改密码规范协议，SSL警报协议，SSL记录协议组成

### HTTP通信过程

* 1 构建请求

* 2 通过DNS映射IP地址

* 3 三次握手建立连接

* 4 发送请求头信息

* 5 服务端响应请求，数据以ASCII字符串返回给客户端

* 6 传输完成，四次挥手断开连接

### 浏览器输入一个地址。到页面展示中间经历了哪些步骤？

网络层：（[001: 说一说从输入URL到页面呈现发生了什么？——网络篇 | 神三元的博客](http://47.98.159.95/my_blog/browser-render/001.html)）

* 构建请求行

* 查找强缓存

* DNS解析

* 建立TCP连接

* 发送HTTP请求

解析过程：

* 构建DOM树（标记化算法，建树算法）

* 样式计算（格式化样式表<结构化的对象>，标准化样式属性<bold=>700>，计算每个节点的具体样式<继承和层叠>）

* 生成布局树（layout tree, 遍历DOM树节点，添加到布局树，计算布局树节点的坐标位置）

渲染过程：

* 建立图层树（因为需要考虑一些复杂场景，如3D动画如何呈现出变换效果，当元素含有层叠上下文如何控制显示和隐藏，所以需要构建一颗图层树，一般情况下，节点的图层会默认属于父亲节点的图层，有两种合成会形成单独的合成层：
  
  * 显式合成：<通过某些css 属性拥有层叠上下文>，
    
    * HTML根元素本身就具有层叠上下文。
    
    * 普通元素设置**position不为static**并且**设置了z-index属性**，会产生层叠上下文。
    
    * 元素的 **opacity** 值不是 1
    
    * 元素的 **transform** 值不是 none
    
    * 元素的 **filter** 值不是 none
    
    * 元素的 **isolation** 值是isolate
    
    * will-change指定的属性值为上面任意一个。
  
  * 隐式合成：`层叠等级低`的节点被提升为单独的图层之后，那么`所有层叠等级比它高`的节点**都会**成为一个单独的图层。

* 生成绘制列表：渲染引擎会将图层的绘制拆分成一个个绘制指令，比如先画背景、再描绘边框......然后将这些指令按顺序组合成一个待绘制列表

* 生成图块和生成位图：渲染进程中绘制操作由合成线程来完成。会将图层进行分块进行绘制。渲染进程中专门维护一个栅格化线程池，专门负责把图块转换为位图数据。合成线程会选择视口附近的图块，把它交给栅格化线程池生成位图。生成位图过程中实际上会使用GPU进行加速，生成的位图最后返回合成线程。

* 显示器显示内容：栅格化之后，合成线程发送绘制命令，发给浏览器进程，浏览器进程接收到后把页面绘制到内存，然后发送到显卡。显卡合成相应的图像， 并保存后缓冲区，然后系统自动将后缓冲区的图像放到显卡前缓冲区进行展示。（当动画占用大量内存的时候，浏览器生成图像就会变慢，传给显卡就会不及时，导致显示器出现卡顿和掉帧）

### cookies机制和session机制的区别：

* 作用范围：cookie 保存在客户端，session保存在服务器（只能在本窗口以及其子窗口内有效。假如两个浏览器窗口互不相干，它们将运用两个不同的Session）

* 有效期：Cookie可以设置为长时间保持，Session 一般客户端关闭或Session超时都会失效

* 隐私策略：Cookie 存在客户端，比较容易被窃取，Session存在服务端

* 存储大小：单个Cookie保存的数据不能超过4K，Session 可存储数据远高于Cookie

如果客户端禁用了cookie，如何保证整个机制正常运转

* 服务端返回的sessionid 客户端保存下来，可以通过post提交，或者地址拼接等方式

* Token

分布式Session解决方案

* Nginx ip_hash 服务器用nginx， 每个请求按访问ip hash固定分配到某个服务器

* Session复制，任何一个服务器上的Session发生改变，该节点自动广播给其他节点

* 共享Session,服务端无状态，将用户的Session等信息使用缓存中间件统一处理，保障发到每一个服务器的响应结果一致。（优选）

### HTTP请求报文与响应报文格式

类似于TCP，HTTP 也是header+ body结构，起始行+头部+空行+实体

* 请求报文
  
     Method + URL + VERSION CRLF GET     /home HTTP/1.1

* 响应报文
  
    VERSION + Status Code + Reason CRLF    HTTP/1.1 200 OK

空行很重要，用来区分头部和实体，如果在头部中间增加一个空行，那么空行后面的内容全部视为实体。

### 一次完整的HTTP请求所经历的7个步骤

* 建立TCP连接

* web浏览器向服务器发送请求命令

* 浏览器发送请求头信息

* 服务器应答

* 服务器发送应答头信息

* 服务器发送数据

* 服务器关闭TCP连接

### HTTP优化方案

应用：

* 减少DNS查找

* 复用TCP链接

* 减少重定向

* 使用CDN

* 客户端缓存资源

* 压缩资源

协议方面

http /1.1 http/2, http/3 都是在对http 协议进行优化，从底层方面进行优化

### HTTP优点缺点

优点：

* 简单，灵活，易于扩展：基本的报文格式，head+body, 而且头部字段允许开发者定制扩充（例如cookie,set-cookie,refresh,content-type,这些都是1.1规范 没定义）

* 应用广，跨平台，跨语言

* 无状态

* 明文

* 传输可靠

缺点：

* 明文不安全（协议里的报文不使用二进制，而是文本）

* 性能（http/3）

* 无状态

* 队头堵塞

### URI和URL的区别

URL 是网址，(Uniform Resource Locator)，统一资源定位器；

URI 全称为（Uniform Resource Identifier）也就是统一资源标识符，用来区分互联网上不同的资源。URI 只能使用`ASCII`, ASCII 之外的字符是不支持显示的。URI 引入了`编码`机制，将所有**非 ASCII 码字符**和**界定符**转为十六进制字节值，然后在前面加个`%`。

URI包含了URN和URL两个部分（URN定义某事物的身份，而URL提供查找该事物的方法。URN仅用于命名，而不指定地址。）

完整的URL结构：

scheme://user:passwd@ host:port path ?quire#fragment

* scheme 标识协议名，比如http,https,file等

* user:passwd@标识登陆主机时的用户信息，不过很不安全，不常用也不推荐使用

* host:port 表示主机名和端口

* path：表示请求路径，标记资源所在位置

* query 表示查询参数

* fragment: 表示URI所定位的资源被的一个锚点

### 如何判断是否为http

* 请求报文起始行中应该有指明http版本信息

### HTTP 1.1引入分块传输编码提供了以下几点好处

* HTTP分块传输编码允许服务器为动态生成的内容维持HTTP持久连接。通常，持久链接需要服务器在开始发送消息体前发送Content-Length消息头字段，但是对于动态生成的内容来说，在内容创建完之前是不可知的。[动态内容，content-length无法预知，当生成回应的时候无法确定消息大小时，服务器可以使用chunked编码，在消息的头部指定transfer-coding域值为chunked]

* 分块传输编码允许服务器在最后发送消息头字段。对于那些头字段值在内容被生成之前无法知道的情形非常重要，例如消息的内容要使用散列进行签名，散列的结果通过HTTP消息头字段进行传输。没有分块传输编码时，服务器必须缓冲内容直到完成后计算头字段的值并在发送内容前发送这些头字段的值。[散列签名，需缓冲完成才能计算]

* HTTP服务器有时使用压缩 （gzip或deflate）以缩短传输花费的时间。分块传输编码可以用来分隔压缩对象的多个部分。在这种情况下，块不是分别压缩的，而是整个负载进行压缩，压缩的输出使用本文描述的方案进行分块传输。在压缩的情形中，分块编码有利于一边进行压缩一边发送数据，而不是先完成压缩过程以得知压缩后数据的大小。[gzip压缩，压缩与传输同时进行]

### 常见web攻击

* XSS攻击（跨站脚本攻击）
  
  * 1反射形攻击： 指攻击代码通过 url 提交到服务器处理并返回到客服端，最终由浏览器执行造成攻击。比如 url 中参数是一段攻击代码<script>alert(1)</script>，被放到 dom 中执行。  * 
  
  * 2 存储型攻击：持久型 XSS，主要是将 XSS 代码发送到服务器（不管是数据库、内存还是文件系统等。），然后等浏览器执行该代码造成攻击  
  
  * 3 DOM XSS 而是通过浏览器端的 DOM 解析。这完全是客户端的事情。DOM XSS 代码的攻击发生的可能在于我们编写 JS 代码造成的

* CSRF（跨站请求伪造）：通过伪装成受信任用户的进行访问，通俗的讲就是说我访问了A网站，然后cookie存在了浏览器，然后我又访问了一个流氓网站，不小心点了流氓网站一个链接（向A发送请求），这个时候流氓网站利用了我的身份对A进行了访问。解决：1采用token认证，2 通过referer识别

* SQL注入: 通过sql命令伪装成正常的http请求参数，传递到服务器端，服务器执行sql命令造成对数据库进行攻击。栗子：当我们输如用户名 jiajun ，然后密码输如`'or '1'= '1`的时候，我们在查询用户名和密码是否正确的时候，本来要执行的是`select * from user where username='' and password=''`,经过参数拼接后，会执行sql语句 `select * from user where username='jaijun' and password=' ' or ' 1'='1 '`，这个时候1=1是成立，自然就跳过验证了。

* DDOS：分布式拒绝服务攻击（Distributed Denial of Service），简单说就是发送大量请求是使服务器瘫痪。

### 站内跳转和外部重定向有何区别

1 数据共享方面：内部跳转是通过服务器转发请求，处理程序那边可以获取到请求对象，和属性参数等等，外部重定向是服务端发送一个指令，客户端重新请求服务端，这个时候拿到的request对象已经不是第一次请求的request对象，

2 网址url 不同

3 请求次数：内部跳转只请求一次（发生在服务端），重定向需要请求两次（浏览器端）

### HTTP的keep-alive是干什么的？（长连接与短连接的区别，以及应用场景）

HTTP/1.1支持使用keep-alive选项来开启长链接（并不是HTTP1.1可以建立长连接，而是它支持以请求头的方式进行长连接发起，长连接是指TCP链接，复用TCP链接），也就是TCP连接会维持一段时间(不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（apache）中设定这个时间)，这样在这段时间内这个连接上的数据就能够直接传输而不需要再次进行耗时的TCP建立连接的过程了。长连接多用于操作频繁，点对点通讯，而且连接数不能太多的情况。例如数据库的连接用长连接。像web网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，因为网站可能会有大量的用户同时使用，如果每个用户都占用一个连接，会对服务器造成巨大的压力。

目前实现即时通讯的有四种方式（短轮询、长轮询、SSE<Server-sent Events`服务器推送事件>、`Websocket`<应用层协议，双向通信协议，基于HTTP协议>）

### 关于Http 2.0 你知道多少？

[参考资料](https://juejin.im/post/5b88a4f56fb9a01a0b31a67e#)

* 多路复用：每个TCP 连接中都承载了多个双向流通的流，每个请求都当作一个流，每一个流都有一个独一无二的标识和优先级，最小的传输单位是二进制帧，由帧构成流。每个二进制帧的头部信息会标识自己属于哪个流，所以可以交错传输，解决线头阻塞的问题。

* 使用二进制进行数据编码和解码

* 头部压缩：使用了专门为首部压缩设计的HPACK算法

* 服务端推送：浏览器发送一个请求，服务端可以主动向浏览器推送与这个请求相关的资源，相较于1.1资源内联的优势：1，客户端可以缓存推送的资源，2 客户端可以拒收推送的资源，3推送资源可以不用页面共享，4服务器可以按照优先级推送资源

* 请求优先级设置：每个流都可以设置依赖和权重，解决关键请求被阻塞的问题

* 流量控制：多路复用的流会竞争TCP资源，进而导致流被阻塞，流控制几只能确保同一连接上的流不会相互干扰，流量控制作用于单个流或整个连接。HTTP/2通过WINDOW_UPDATE帧来提供流量控制机制
  
  * 流量控制特定于连接，并且位于单跳的端点志坚，而不是整个端到端的路径，比如client-nginx-server，整个时候就会有两个connection, client-nginx, nginx-server,flow 控制分别作用于两个connection.
  
  * 流量控制是基于WINDOW_UPDATE帧，接收方公布自己打算在每个流以及整个连接上分别接收多少字节
  
  * 流量控制是有方向的，由接收方控制。接收方可以为每个流和整个连接设置任意窗口大小。
  
  * 流量控制窗口的初始值是65535字节。
  
  * 帧的类型决定了流量控制是否适用于帧，只有DATA帧会受流量控制影响，其他类型的帧并不消耗流量控制窗口的空间。
  
  * 流量控制不能被禁用

### 强缓存

* （http1.1）Cache-Control：
  
  * Max-Age 允许获取的响应被重用的最长时间(单位为秒,
  
  * public: 表示该响应可以再浏览器或者任何中继的Web代理中缓存,
  
  * private ：表示只有用户的浏览器可以缓存private响应
  
  * no-cache：那么浏览器在使用缓存的资源之前，必须先与服务器确认返回的响应是否被更改（Etag），如果资源未被更改，可以避免下载
  
  * no-store: 浏览器和任何中继的Web代理，都不会存储这次相应的数据。当下次请求该资源时，浏览器只能重新请求服务器，重新从服务器读取资源。

* （http1.0）Pragma/Expires expiress: 时间戳， 有个致命缺点，他是以服务端的时间为准，如果客户端的时间和服务端的时间不一致，那就可能导致资源失效。

* max-age 优先于 expires

### 讲讲304(协商缓存)缓存的原理

* http 1.1 ，使用If-None-Match/E-tag来进行协商， 浏览器的头部是 If-None-Match，首次请求服务端返回 E-tag（可以是hash,或者自己维护的内部版本号），第二次请求该资源，浏览器的头部会带上 If-None-Match（记录的是Etag），如果 If-None-Match 和 E-tag 匹配，则代表内容未变，通知浏览器使用本地缓存。

* http/1.0 ,使用If-Modified-Since/Last-Modified，两者方式同上，只是记录的是修改时间

* E-tag 和 Last-Modified，服务端会优先检查 E-tag 

### HTTP与RPC异同

* 从传输协议来说，RPC既可以基于TCP 也可以基于HTTP协议，但是HTTP通常是基于TCP

* 从性能消耗上：RPC可以基于thrift 实现高效二进制传输。HTTP大部分通过json实现，无论从字节大小还是序列化耗时逗比thrift耗时

* 从负载均衡上：RPC基本上自带负载均衡策略，而HTTP需要配置Nginx实现
